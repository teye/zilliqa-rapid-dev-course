"use strict";(self.webpackChunkcourse=self.webpackChunkcourse||[]).push([[801],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=r,h=m["".concat(s,".").concat(u)]||m[u]||p[u]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2744:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={sidebar_position:6},s="Remote State Reads",c={unversionedId:"scilla/remote_state_reads",id:"scilla/remote_state_reads",isDocsHomePage:!1,title:"Remote State Reads",description:"Remote state read is a feature in Scilla that allows a deployed contract to read the mutable fields of another deployed contract.",source:"@site/docs/scilla/remote_state_reads.md",sourceDirName:"scilla",slug:"/scilla/remote_state_reads",permalink:"/zilliqa-tldr-dapp-course/docs/scilla/remote_state_reads",editUrl:"https://github.com/teye/zilliqa-tldr-dapp-course/docs/scilla/remote_state_reads.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Custom ADT(s)",permalink:"/zilliqa-tldr-dapp-course/docs/scilla/custom_adts"},next:{title:"Zilliqa API",permalink:"/zilliqa-tldr-dapp-course/docs/zilliqa-js/api"}},d=[{value:"Declaration in Contract Definition",id:"declaration-in-contract-definition",children:[{value:"Syntax",id:"syntax",children:[],level:4},{value:"Example",id:"example",children:[],level:4}],level:2},{value:"Declaration in Transition Parameters",id:"declaration-in-transition-parameters",children:[{value:"Syntax",id:"syntax-1",children:[],level:4},{value:"Example",id:"example-1",children:[],level:4}],level:2},{value:"Read Remote Mutable Fields",id:"read-remote-mutable-fields",children:[{value:"Syntax",id:"syntax-2",children:[],level:4},{value:"Example",id:"example-2",children:[],level:4}],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],p={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"remote-state-reads"},"Remote State Reads"),(0,o.kt)("p",null,"Remote state read is a feature in Scilla that allows a deployed contract to read the ",(0,o.kt)("strong",{parentName:"p"},"mutable fields")," of another deployed contract."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": Only mutable fields can be fetched via remote state reads."),(0,o.kt)("p",null,"There are two ways to access the mutable fields of another deployed contract. (1) By declaring the remote contract address in the ",(0,o.kt)("strong",{parentName:"p"},"contract definition")," and (2) By declaring the remote contract address in the ",(0,o.kt)("strong",{parentName:"p"},"transition parameters"),"."),(0,o.kt)("h2",{id:"declaration-in-contract-definition"},"Declaration in Contract Definition"),(0,o.kt)("p",null,"The easiest way to access a remote mutable field is to declare the remote contract address in the contract definition.\nWe can read one mutable field or unlimited mutable fields as long as the remote contract address has that mutable field."),(0,o.kt)("h4",{id:"syntax"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  contract MyContract\n  (\n      owner: ByStr20,\n      remote_contract_address: ByStr20 with contract\n        field mutable_field1_name: <mutable_field1_type>,\n        field mutable_field2_name: <mutable_field2_type>,\n      end\n  )\n")),(0,o.kt)("h4",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  contract Marketplace\n  (\n      owner: ByStr20,\n      cryptomons: ByStr20 with contract\n        field token_owners: Map Uint256 ByStr20\n      end\n  )\n")),(0,o.kt)("p",null,"Suppose, we have a Marketplace contract that allows users to trade Cryptomons. The Marketplace contract must know the owners of the Cryptomons before it can allow users to trade with one another. To do that we need to perform remote state read."),(0,o.kt)("p",null,"The Marketplace contract is deployed with a ",(0,o.kt)("inlineCode",{parentName:"p"},"owner")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," as a immutable field. The ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," field is a remote contract that has already been deployed. To access the mutable fields of this ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," contract, we need to declare it in the contract definition first."),(0,o.kt)("p",null,"We introduced a new Scilla syntax: ",(0,o.kt)("inlineCode",{parentName:"p"},"ByStr20 with contract ... end"),". In Scilla a ",(0,o.kt)("inlineCode",{parentName:"p"},"ByStr20")," is an address. An address can either be a contract address or wallet address. The ",(0,o.kt)("inlineCode",{parentName:"p"},"ByStr20 with contract")," is a syntax to inform Scilla that we are going to access a ",(0,o.kt)("inlineCode",{parentName:"p"},"ByStr20")," address that is of a contract type."),(0,o.kt)("p",null,"Next, we define the mutable fields of this ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," contract which we want to read. For instance, if we wish to access ",(0,o.kt)("inlineCode",{parentName:"p"},"token_owners")," field in the ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," contract from the Marketplace contract, we list the ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," field like how we declare the usual mutable field syntax."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"token_owners")," can only be accessed from ",(0,o.kt)("inlineCode",{parentName:"p"},"Marketplace")," contract if ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," contract has the mutable field ",(0,o.kt)("inlineCode",{parentName:"p"},"token_owners"),". If the ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," contract does not have ",(0,o.kt)("inlineCode",{parentName:"p"},"token_owners")," mutable field, then an error would be thrown when we try to deploy this ",(0,o.kt)("inlineCode",{parentName:"p"},"Marketplace")," contract."),(0,o.kt)("h2",{id:"declaration-in-transition-parameters"},"Declaration in Transition Parameters"),(0,o.kt)("p",null,"Similar to how we declared the remote contract address in the contract definition, we can do the same in the transition parameters."),(0,o.kt)("h4",{id:"syntax-1"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  transition transitionName(\n      remote_contract_address: ByStr20 with contract\n        field mutable_field_name1: <mutable_field_type>,\n        field mutable_field_name2: <mutable_field_type2>\n      end\n  )\n  end\n")),(0,o.kt)("h4",{id:"example-1"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  transition Trade(\n      cryptomons: ByStr20 with contract\n        field token_owners: Map Uint256 ByStr20\n      end\n  )\n  end\n")),(0,o.kt)("h2",{id:"read-remote-mutable-fields"},"Read Remote Mutable Fields"),(0,o.kt)("p",null,"Now that we've learnt how to declare the remote contract address, we need to understand how to read the mutable fields which we have just declared."),(0,o.kt)("h4",{id:"syntax-2"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  contract MyContract\n  (\n      owner: ByStr20,\n      remote_contract_address: ByStr20 with contract\n        field mutable_field1_name: <mutable_field1_type>,\n        field mutable_field2_name: <mutable_field2_type>,\n      end\n  )\n\n  transition transitionName()\n    my_mutable_field_1 <-& remote_contract_address.mutable_field1_name;\n    my_mutable_field_2 <-& remote_contract_address.mutable_field2_name;\n  end\n")),(0,o.kt)("h4",{id:"example-2"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  contract Marketplace\n  (\n      owner: ByStr20,\n      cryptomons: ByStr20 with contract\n        field token_owners: Map Uint256 ByStr20\n      end\n  )\n\n  transition Trade(cryptomon_id: Uint256)\n    existing_owner <-& cryptomons.token_owners[cryptomon_id];\n    is_sender = builtin eq _sender existing_owner;\n    match is_sender with\n    | False =>\n      err = CodeNotTokenOwner;\n      ThrowError err\n    | True =>\n  end\n")),(0,o.kt)("p",null,"To the remote mutable field, we use the syntax ",(0,o.kt)("inlineCode",{parentName:"p"},"<-&"),". As shown in the above example, we first declare the remote contract address in the contract definition. Next, in the transition, we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"<-&")," syntax to access the ",(0,o.kt)("inlineCode",{parentName:"p"},"token_owners")," field from the ",(0,o.kt)("inlineCode",{parentName:"p"},"cryptomons")," declaration and assigned it to an ",(0,o.kt)("inlineCode",{parentName:"p"},"existing_owner")," variable. In this way, we can read the cryptomons contract to check if this cryptomon that we are going to trade belongs to this sender or not."),(0,o.kt)("h2",{id:"exercises"},"Exercises"),(0,o.kt)("p",null,"The following are some exercises to help you be familiar with remote state reads."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Instructions")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Download this ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/teye/zilliqa-tldr-dapp-course/blob/main/exercises/chapter1/ch01_remote_state_read_cryptomon.scilla"},(0,o.kt)("strong",{parentName:"a"},"Cryptomon Contract"))," and ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/teye/zilliqa-tldr-dapp-course/blob/main/exercises/chapter1/ch01_remote_state_read_marketplace.scilla"},(0,o.kt)("strong",{parentName:"a"},"Marketplace Contract"))," to get started.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Task")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Deploy the ",(0,o.kt)("strong",{parentName:"li"},"Cryptomon")," contract on  ",(0,o.kt)("a",{parentName:"li",href:"https://ide.zilliqa.com/"},(0,o.kt)("strong",{parentName:"a"},"Neo-Savant IDE"))," on ",(0,o.kt)("strong",{parentName:"li"},"Simulated Env"),"."),(0,o.kt)("li",{parentName:"ul"},"Deploy the ",(0,o.kt)("strong",{parentName:"li"},"Marketplace")," contract, for the ",(0,o.kt)("inlineCode",{parentName:"li"},"cryptopmons")," parameter, use the address from above."),(0,o.kt)("li",{parentName:"ul"},"In the ",(0,o.kt)("strong",{parentName:"li"},"Cryptomon")," contract, execute ",(0,o.kt)("inlineCode",{parentName:"li"},"AddCryptoMon(1, <your_wallet_address>)"),"."),(0,o.kt)("li",{parentName:"ul"},"Using a ",(0,o.kt)("strong",{parentName:"li"},"different wallet address"),", in the ",(0,o.kt)("strong",{parentName:"li"},"Marketplace")," contract, execute ",(0,o.kt)("inlineCode",{parentName:"li"},"CreateTrade(1, 100)"),".",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Observe the transaction logs for events."),(0,o.kt)("li",{parentName:"ul"},"You should see error ",(0,o.kt)("inlineCode",{parentName:"li"},"-1")," which is ",(0,o.kt)("inlineCode",{parentName:"li"},"CodeNotTokenOwner")," being thrown."),(0,o.kt)("li",{parentName:"ul"},"This implies our remote state read is working as intended."))),(0,o.kt)("li",{parentName:"ul"},"Switch back the ",(0,o.kt)("strong",{parentName:"li"},"original")," wallet address which executes ",(0,o.kt)("inlineCode",{parentName:"li"},"AddCryptoMon(1)")," and call ",(0,o.kt)("inlineCode",{parentName:"li"},"CreateTrade(1, 100)")," in the ",(0,o.kt)("strong",{parentName:"li"},"Marketplace")," contract.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Observe the transaction logs for events."),(0,o.kt)("li",{parentName:"ul"},"You should see a ",(0,o.kt)("inlineCode",{parentName:"li"},"CreateTrade")," event being emitted.")))))}m.isMDXComponent=!0}}]);