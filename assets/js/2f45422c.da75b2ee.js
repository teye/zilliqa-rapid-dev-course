"use strict";(self.webpackChunkcourse=self.webpackChunkcourse||[]).push([[183],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return k}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),c=d(n),k=r,u=c["".concat(l,".").concat(k)]||c[k]||m[k]||i;return n?a.createElement(u,o(o({ref:t},s),{},{components:n})):a.createElement(u,o({ref:t},s))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1516:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return s},default:function(){return c}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],p={sidebar_position:3},l="Maps",d={unversionedId:"scilla/maps",id:"scilla/maps",isDocsHomePage:!1,title:"Maps",description:"In Scilla, Maps and Lists are two of the core data types that can store complex data. In particular, Maps are more widely used in almost all of the contracts.",source:"@site/docs/scilla/maps.md",sourceDirName:"scilla",slug:"/scilla/maps",permalink:"/docs/scilla/maps",editUrl:"https://github.com/teye/zilliqa-tldr-dapp-course/docs/scilla/maps.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Transitions & Procedures",permalink:"/docs/scilla/transitions_procedures"},next:{title:"Events & Errors",permalink:"/docs/scilla/events_errors"}},s=[{value:"Declaration",id:"declaration",children:[{value:"Syntax",id:"syntax",children:[],level:4},{value:"Example",id:"example",children:[],level:4}],level:2},{value:"Add / Overwrite Map Entries",id:"add--overwrite-map-entries",children:[{value:"Syntax",id:"syntax-1",children:[],level:4},{value:"Example",id:"example-1",children:[],level:4}],level:2},{value:"Delete Map Entries",id:"delete-map-entries",children:[{value:"Syntax",id:"syntax-2",children:[],level:4},{value:"Example",id:"example-2",children:[],level:4}],level:2},{value:"Improve Add / Delete Map Entries",id:"improve-add--delete-map-entries",children:[{value:"Add Map Example with Checks",id:"add-map-example-with-checks",children:[],level:4},{value:"Delete Map Example with Checks",id:"delete-map-example-with-checks",children:[],level:4}],level:2},{value:"Nested Maps - Declaration",id:"nested-maps---declaration",children:[{value:"Syntax",id:"syntax-3",children:[],level:4},{value:"Example",id:"example-3",children:[],level:4}],level:2},{value:"Nested Maps - Add / Overwrite Entries",id:"nested-maps---add--overwrite-entries",children:[{value:"Syntax",id:"syntax-4",children:[],level:4},{value:"Example",id:"example-4",children:[],level:4}],level:2},{value:"Nessted Maps - Delete Entries",id:"nessted-maps---delete-entries",children:[{value:"Syntax",id:"syntax-5",children:[],level:4},{value:"Example",id:"example-5",children:[],level:4},{value:"Proper Nested Maps Deletion",id:"proper-nested-maps-deletion",children:[{value:"Example",id:"example-6",children:[],level:4}],level:3}],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],m={toc:s};function c(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"maps"},"Maps"),(0,i.kt)("p",null,"In Scilla, ",(0,i.kt)("inlineCode",{parentName:"p"},"Maps")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Lists")," are two of the core data types that can store complex data. In particular, ",(0,i.kt)("inlineCode",{parentName:"p"},"Maps")," are more widely used in almost all of the contracts."),(0,i.kt)("h2",{id:"declaration"},"Declaration"),(0,i.kt)("p",null,"To declare a new map, we defined it as a mutable field in the contract and assigned a ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," for the key and value which it can hold. We also assigned an empty map - denoted by ",(0,i.kt)("inlineCode",{parentName:"p"},"Emp")," to the new map field."),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"contract ContractName()\n  field map_name: Map Type1 Type2 = Emp Type1 Type2\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Type1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Type2")," can be the same type."),(0,i.kt)("li",{parentName:"ul"},"Nested maps are possible.")),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"contract CryptoMon()\n  (* Mapping of token_id -> owner_address *)\n  field token_owners: Map Uint256 ByStr20 = Emp Uint256 ByStr20\n")),(0,i.kt)("p",null,"In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners")," is a map ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint256 -> ByStr20")," the key is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint256")," and the value is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"ByStr20"),", the contract state would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'token_owners : {\n    "1": "0x1234567890123456789012345678901234567890",\n    "2": "0x1234567890123456789012345678901234567890",\n}\n')),(0,i.kt)("h2",{id:"add--overwrite-map-entries"},"Add / Overwrite Map Entries"),(0,i.kt)("p",null,"To add a new map entry, assign a new key and value to the map. This is also known as in-place access."),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition transitionName()\n    map_name[key] := value\n  end\n")),(0,i.kt)("h4",{id:"example-1"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition AddMap(id: Uint256, address: ByStr20)\n    token_owners[id] := address\n  end\n")),(0,i.kt)("p",null,"In the above example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddMap()")," transition takes in an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," and updates the ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners")," map. This allow us to overwrite existing map entries with new values."),(0,i.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"danger")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Always update the map ",(0,i.kt)("strong",{parentName:"p"},"in-place"),".\nDo not copy a new map, update the map and re-assigned it back! "),(0,i.kt)("p",{parentName:"div"},"This is slow and consumes a lot of gas!"),(0,i.kt)("p",{parentName:"div"},"DON'T DO THIS:"),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre"},"  transition AddMap(id: Uint256, address: ByStr20)\n    new_token_owners <- token_owners;\n    new_token_owners[id] := address;\n    token_owners := new_token_owners\n  end\n")))),(0,i.kt)("h2",{id:"delete-map-entries"},"Delete Map Entries"),(0,i.kt)("p",null,"To delete a map entry, simply use the ",(0,i.kt)("inlineCode",{parentName:"p"},"delete")," keyword on the particular map entry."),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition transitionName()\n    delete map_name[key]\n  end\n")),(0,i.kt)("h4",{id:"example-2"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition DeleteMap(id: Uint256)\n    delete token_owners[id]\n  end\n")),(0,i.kt)("p",null,"The above example deletes the specific ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners[id]")," entry from the map. "),(0,i.kt)("p",null,"If a map is empty, the contract state would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"  token_owners: {}\n")),(0,i.kt)("h2",{id:"improve-add--delete-map-entries"},"Improve Add / Delete Map Entries"),(0,i.kt)("p",null,"Now, we can improve the adding and deleting of map entries by putting additional checks."),(0,i.kt)("h4",{id:"add-map-example-with-checks"},"Add Map Example with Checks"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition AddMap(id: Uint256, address: ByStr20)\n    owner <- token_owners[id];\n    match owner with\n    | Some existing_owner =>\n      (* owner already exists for this token_id; do nothing or throw error *)\n    | None =>\n      (* no such owner; proceed to add *)\n      token_owners[id] := address\n    end\n  end\n")),(0,i.kt)("p",null,"First, we tried to fetch an owner for the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," supplied by the user. Next we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"match owner with")," syntax to check whether any owner address is being fetched. The new item is added into the map only if the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," is not already owned by anyone yet. If it is already owned, we do not want to overwrite the map."),(0,i.kt)("p",null,"In other languages, the logic can be interpreted as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  const owner = token_owners[id];\n  if (owner !== undefined) {\n    // do nothing\n  } else {\n    // add to map\n    token_owners[id] = owner;\n  }\n")),(0,i.kt)("h4",{id:"delete-map-example-with-checks"},"Delete Map Example with Checks"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition DeleteMap(id: Uint256)\n    owner <- token_owners[id];\n    match owner with\n    | Some existing_owner =>\n      (* owner exists for this token_id; proceed to delete *)\n      delete token_owners[id]\n    | None =>\n      (* no such owner for this token_id to delete; throw error *)\n    end\n  end\n")),(0,i.kt)("p",null,"Similar to the above add map example, first, we attempt to fetch an ",(0,i.kt)("inlineCode",{parentName:"p"},"owner")," for this ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," that we wish to delete. Next. we check whether if this ",(0,i.kt)("inlineCode",{parentName:"p"},"owner")," is undefined or not. If ",(0,i.kt)("inlineCode",{parentName:"p"},"owner")," is undefined as shown by the ",(0,i.kt)("inlineCode",{parentName:"p"},"| None =>")," branch, that implies the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," does not exists in ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners")," map. If ",(0,i.kt)("inlineCode",{parentName:"p"},"owner")," is defined, then we proceed to delete the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners"),"."),(0,i.kt)("p",null,"In other languages, the logic can be interpeted as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  const owner = token_owners[id];\n  if (owner !== undefined) {\n    // delete from map\n    delete token_owners[id]\n  } else {\n    // throw error\n  }\n")),(0,i.kt)("br",null),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},'You might have noticed that we have added the comments "throw error" in the example code. '),(0,i.kt)("p",{parentName:"div"},"The topic on throwing errors and emiting events is covered in the next section ",(0,i.kt)("a",{parentName:"p",href:"/docs/scilla/events_errors"},(0,i.kt)("strong",{parentName:"a"},"Events & Errors")),"."))),(0,i.kt)("br",null),(0,i.kt)("br",null),(0,i.kt)("h1",{id:"intermediate---nested-maps-optional"},"Intermediate - Nested Maps (Optional)"),(0,i.kt)("p",null,"Nested maps are maps whose value point to a key of the second map. There is no limit to the number of nesting levels."),(0,i.kt)("h2",{id:"nested-maps---declaration"},"Nested Maps - Declaration"),(0,i.kt)("p",null,"Identical to how we declare a non-nested map, we first define a mutable field in the contract and assigned a ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," for the key and value which it can hold. We also assigned an empty map - denoted by ",(0,i.kt)("inlineCode",{parentName:"p"},"Emp")," to the new map field."),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"contract ContractName()\n  field map_name: Map Type1 (Map Type2 Type3) = Emp Type1 (Map Type2 Type3)\n")),(0,i.kt)("h4",{id:"example-3"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"contract SuperMarket()\n  (* Mapping of category_id -> product_id -> name *)\n  field products: Map Uint256 (Map Uint256 String) = Emp Uint256 (Map Uint256 String)\n")),(0,i.kt)("p",null,"In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"products")," is a map ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint256 -> (Map Uint256 String)")," the key is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint256")," and the value is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),". Within the nested map, we have ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint256 -> String")," "),(0,i.kt)("p",null,"the contract state would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'products : {\n    "1": {\n      "42": "red apple",\n      "43": "green apple",\n      "44": "orange"\n    },\n    "2": {\n      "27": "celery",\n      "28": "spinach",\n      "29": "cabbage"\n    },\n}\n')),(0,i.kt)("h2",{id:"nested-maps---add--overwrite-entries"},"Nested Maps - Add / Overwrite Entries"),(0,i.kt)("p",null,"Adding an entry into a nested map is identical to the non-nested one."),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition transitionName()\n    map_name[key1][key2] := value\n  end\n")),(0,i.kt)("h4",{id:"example-4"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition AddMap(category_id: Uint256, product_id: Uint256, name: String)\n    products[category_id][product_id] := name\n  end\n")),(0,i.kt)("h2",{id:"nessted-maps---delete-entries"},"Nessted Maps - Delete Entries"),(0,i.kt)("p",null,"Deleting an entry from a nested map is identical to the non-nested one."),(0,i.kt)("h4",{id:"syntax-5"},"Syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition transitionA()\n    delete map_name[key1][key2]\n  end\n\n  transition transitionB()\n    delete map_name[key1]\n  end\n")),(0,i.kt)("h4",{id:"example-5"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  transition DeleteA(category_id: Uint256, product_id: Uint256)\n    delete products[category_id][product_id]\n  end\n\n  transition DeleteB(category_id: Uint256)\n    delete products[category_id]\n  end\n")),(0,i.kt)("p",null,"In the above examples, the first transition ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteA")," deletes a specific entry from the nested map. However in ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteB"),", the transition ",(0,i.kt)("strong",{parentName:"p"},"deletes the entire nested map"),"."),(0,i.kt)("p",null,"Here is how the contract state would look like if we execute both transitions:"),(0,i.kt)("p",null,"Suppose the initial contract state is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'products : {\n    "1": {\n      "42": "red apple",\n      "43": "green apple",\n      "44": "orange"\n    },\n    "2": {\n      "27": "celery",\n      "28": "spinach",\n      "29": "cabbage"\n    },\n}\n')),(0,i.kt)("p",null,"If we call ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteA(1, 42)"),", the state would become this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'products : {\n    "1": {\n      "43": "green apple",\n      "44": "orange"\n    },\n    "2": {\n      "27": "celery",\n      "28": "spinach",\n      "29": "cabbage"\n    },\n}\n')),(0,i.kt)("p",null,"Observe that the entry ",(0,i.kt)("inlineCode",{parentName:"p"},"42 -> red apple")," has been deleted."),(0,i.kt)("p",null,"If we call ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteB(1)"),", the state would become this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'products : {\n    "2": {\n      "27": "celery",\n      "28": "spinach",\n      "29": "cabbage"\n    },\n}\n')),(0,i.kt)("p",null,"Observe that the entires ",(0,i.kt)("inlineCode",{parentName:"p"},"1 -> { ... }")," has been deleted."),(0,i.kt)("h3",{id:"proper-nested-maps-deletion"},"Proper Nested Maps Deletion"),(0,i.kt)("p",null,"Usually when we delete a map entry, we would delete only a specifc ",(0,i.kt)("inlineCode",{parentName:"p"},"key-value")," pair. For nested maps, this may result in a lot of empty map states."),(0,i.kt)("p",null,"Suppose we have the following map:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'products : {\n    "1": {\n      "42": "red apple",\n      "43": "green apple",\n      "44": "orange",\n      "45": ...,\n      "46": ...\n      ...\n      ...\n      "100": "cherry"\n    },\n    "2": {\n      ...\n    },\n    "3": {\n      ...\n    }\n}\n')),(0,i.kt)("p",null,'If we continously delete an entry from "1", example, delete ',(0,i.kt)("inlineCode",{parentName:"p"},"42 -> red apple"),", next delete ",(0,i.kt)("inlineCode",{parentName:"p"},"43 -> green apple"),', etc. Then the map would have an empty state when all the items within category "1" is deleted:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'products : {\n    "1": {},  <-- empty map state\n    "2": {\n      ...\n    },\n    "3": {\n      ...\n    }\n}\n')),(0,i.kt)("p",null,"If we have many product categories and we perform many entry deletion from a nested map, we would end up with map empty map states!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'products : {\n    "1": {},  <-- empty map state\n    "2": {},\n    "3": {},\n    "4": {},\n    ...\n    ...\n    ...\n    "999": {},\n    "1000": {\n      "20": "jam"\n    }\n}\n')),(0,i.kt)("p",null,"These empty states would slow down the time taken to fetch the contract state! "),(0,i.kt)("p",null,'Hence, we need to delete the "outer layer" in the map once the inner nested entries have all been deleted.'),(0,i.kt)("h4",{id:"example-6"},"Example"),(0,i.kt)("p",null,'In order to delete the "outer layer" map, we need to add the following checks:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  (* Library *)\n  import ListUtils IntUtils\n\n  let uint32_zero = Uint32 0\n\n  (* check if nested maps are empty *)\n  let is_products_map_empty =\n    fun(m : Map Uint256 String) =>\n      let map_size = builtin size m in\n      builtin eq map_size uint32_zero\n\n  (***************************************************)\n  (*             The contract definition             *)\n  (***************************************************)\n  contract SuperMarket()\n\n  (* Deletes the category if the nested map is empty *)\n  procedure DeleteCategory(category_id: Uint256)\n    products_map <- products[category_id];\n\n    match products_map with\n    | Some products_entry =>\n      is_map_empty = is_products_map_empty products_entry;\n\n      match is_map_empty with\n      | True => \n        (* empty map *)\n        delete products[category_id]\n      | False =>\n        (* contains other records *)\n    | None =>\n        (* nothing to delete *)\n    end\n\n  end\n\n  transition DeleteProduct(category_id: Uint256, product_id: Uint256)\n    delete products[category_id][product_id];\n    DeleteCategory category_id\n  end\n")),(0,i.kt)("p",null,"Let's start with the transition ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteProduct"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteProduct")," deletes a specifc nested map entry ",(0,i.kt)("inlineCode",{parentName:"p"},"products[category_id][product_id"),". After the deletion, it calls the procedure ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteCategory"),"."),(0,i.kt)("p",null,"Inside ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteCategory"),", the transition checks if there exists other nested map entries. Since we have deleted one entry in ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteProduct"),", we need to consider if there are other ",(0,i.kt)("inlineCode",{parentName:"p"},"product_id")," within the same ",(0,i.kt)("inlineCode",{parentName:"p"},"category_id"),", for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'products: {\n  "1": {\n    "43": "green apple",\n    "44": "orange",\n  }\n}\n')),(0,i.kt)("p",null,"This check is done by ",(0,i.kt)("inlineCode",{parentName:"p"},"is_map_empty = is_products_map_empty products_entry;"),". We code our own library function ",(0,i.kt)("inlineCode",{parentName:"p"},"is_products_map_empty")," before the contract definition section."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  let is_products_map_empty =\n    fun(m : Map Uint256 String) =>\n      let map_size = builtin size m in\n      builtin eq map_size uint32_zero\n")),(0,i.kt)("p",null,"What ",(0,i.kt)("inlineCode",{parentName:"p"},"is_products_map_empty")," does is to take in ",(0,i.kt)("inlineCode",{parentName:"p"},"products[1]")," and calculate the size of this map; something like ",(0,i.kt)("em",{parentName:"p"},'"array.size()"')," in other languages. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"is_products_map_empty")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"products[1]")," is empty and ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," otherwise. "),(0,i.kt)("p",null,"In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"products[1]")," has 2 other nested map entries ",(0,i.kt)("inlineCode",{parentName:"p"},"43 -> green apple")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"44 -> orange"),". So the function ",(0,i.kt)("inlineCode",{parentName:"p"},"is_products_map_empty")," will return ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,i.kt)("p",null,"Next, we will ",(0,i.kt)("inlineCode",{parentName:"p"},"delete products[1]")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"products[1]")," is empty:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  (* Deletes the category if the nested map is empty *)\n  procedure DeleteCategory(category_id: Uint256)\n    products_map <- products[category_id];\n\n    match products_map with\n    | Some products_entry =>\n      is_map_empty = is_products_map_empty products_entry;\n\n      match is_map_empty with\n      | True => \n        (* empty map *)\n        delete products[category_id]    <-- delete the "outer" layer\n      | False =>\n        (* contains other records *)\n    | None =>\n        (* nothing to delete *)\n    end\n\n  end\n')),(0,i.kt)("p",null,"To summarize, for proper maps deletion in ",(0,i.kt)("strong",{parentName:"p"},"nested maps"),", we code our own ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteProduct")," transition that not only deletes the nested map entry but also the outer layer if the inner layer is empty after the deletion of the nested map entry."),(0,i.kt)("h2",{id:"exercises"},"Exercises"),(0,i.kt)("p",null,"The following are some exercises to help you be familiar with maps."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Instructions")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Download this ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/teye/zilliqa-tldr-dapp-course/blob/main/exercises/chapter1/ch01_cryptomon.scilla"},(0,i.kt)("strong",{parentName:"a"},"Cryptomon Contract"))," to get started.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Task 1")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Define a new map ",(0,i.kt)("inlineCode",{parentName:"li"},"token_owners")," (",(0,i.kt)("inlineCode",{parentName:"li"},"Uint256")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"ByStr20"),") that stores the mapping of ",(0,i.kt)("inlineCode",{parentName:"li"},"token_id")," to users' wallet addresses."),(0,i.kt)("li",{parentName:"ul"},"Define a new transition ",(0,i.kt)("inlineCode",{parentName:"li"},"AddCryptoMon")," that takes in ",(0,i.kt)("inlineCode",{parentName:"li"},"token_id")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"address")," and add the new entry into the ",(0,i.kt)("inlineCode",{parentName:"li"},"token_owners")," map."),(0,i.kt)("li",{parentName:"ul"},"Define a new transition ",(0,i.kt)("inlineCode",{parentName:"li"},"DeleteCryptoMon")," that deletes a specific ",(0,i.kt)("inlineCode",{parentName:"li"},"token_id")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"token_owners"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Task 2")),(0,i.kt)("p",null,"Deploy the contract on ",(0,i.kt)("a",{parentName:"p",href:"https://ide.zilliqa.com/"},(0,i.kt)("strong",{parentName:"a"},"Neo-Savant IDE"))," on ",(0,i.kt)("strong",{parentName:"p"},"Testnet")," and execute ",(0,i.kt)("inlineCode",{parentName:"p"},"AddCryptoMon(wallet_address)"),". "),(0,i.kt)("p",null,"Once the transaction is confirmed, execute ",(0,i.kt)("inlineCode",{parentName:"p"},"AddItem(wallet_address)")," a second time with a different ",(0,i.kt)("inlineCode",{parentName:"p"},"token_id"),". "),(0,i.kt)("p",null,"Look at the deployed contract state on ",(0,i.kt)("strong",{parentName:"p"},"ViewBlock"),"."),(0,i.kt)("p",null,"The contract state should look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'token_owners : {\n    "1": "0x<wallet_address>",\n    "2": "0x<wallet_address>",\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Task 3")),(0,i.kt)("p",null,"Return back to Neo-Savant IDE, execute ",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteCryptoMon")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"token_id")," - ",(0,i.kt)("strong",{parentName:"p"},"1"),". "),(0,i.kt)("p",null,"Check the ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners")," state again on ViewBlock."),(0,i.kt)("p",null,"It should look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'token_owners : {\n    "2": "0x<wallet_address>",\n}\n')))}c.isMDXComponent=!0}}]);